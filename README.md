# Graffiti Protocol: Secure Asynchronous Communication over Untrusted Public Databases (pre-alpha extremely rough draft)

by lucash_dev@bitcoinhackers.org

## Motivation

Internet communication among individuals and organizations has increasingly concentrated among fewer service providers, such as LinkedIn, Facebook & Twitter. Their business models include the amassing and selling of surveillance data on users, and providing opportunities to influence user behaviour such as ads, boosted posts and disinformation campaigns. Even if the amassed surveillance data wasn't intended to be used maliciously, more and more Data Breaches see ever more people have their personal data sold or even given away free. <sup>[1](#footnote01)</sup>

Existing decentralized solutions require a trusted server such as [Mastodon](https://joinmastodon.org) or [Matrix](https://matrix.org/) to
manage user identity and often rely on existing trusted
infrastructure such as DNS & PKI certificates for connecting to them. 
Other proposed alternatives[examples in footnotes pls] rely entirely on a friend-to-friend connectivity graph and other less resilient methods.

Countering these weaknesses requires research to keep moving in the direction of protocols that can easily allow for trust-minimized communication between any two network clients. This paper introduces just such a protocol for asynchronous communication by relying on a set of non-trusted database servers.

## Assumptions

1. Trusted third-parties are security holes.

   The protocol should minimize the amount of information any third party can access, and reliance on any third-party for its functioning.

1. Every piece of data transmitted outside of devices physically controlled by users will eventually become public.

   Even though we assume processing of cleartext only happens on devices controlled by the intended users, all data shared with a third party is assumed to eventually become public without compromising the continuation or secrecy of the communication.

1. Unsolicited messages are DoS attacks.

   Ads sent by spambots etc are considered attacks on the end user.
   
1. Both ends of a communication can reach at least one common point in the network.

   This protocol will require one or more servers willing to perform a "best effort" to deliver messages -- but which are not trusted in any other way.
   Multiple servers can be used and switching between them should be trivial. Please note that this assumption is essentially the same as
   required for Internet Protocol (IP) communication.

1. That early hand-shaking is made via a side-channel that's temporarily secure

1. Intermediate servers will keep logs pertinent to this protocol

1. Exchanges generated by this protocol are layered on top of HTTP, which itself may be on top of SSL.

## Goal

The goal of this protocol is to allow bi-directional transfer of information between any two users that is end-to-end encrypted and is trust-minimized,
without requiring continuously running a trusted server.

Extensions to allow for multi-cast, public inboxes, and public broadcast will be briefly discussed.

## General architecture

TODO: Insert diagram here

Elements of the architecture:

1. Database Server(s)

1. Clients

## The Database

In this document we will refer to "the database" as dealing with just one server makes explanation simpler, but it will become obvious that a number of database servers can be used as long as both clients can access at least one of them.

The database used for this protocol is a very simplified datastore:

1. Reading: all clients may read all data without authentication
1. Writing: restricted as explained below
1. Only one alphanumerical index which must allow both exact- and range-queries.

The database must implement those two primitives:

1. STORE:  
   A STORE request shares with the server a piece of data -- a *Parcel* -- that is to be stored within the database.
   A parcel is composed of:  
    * A *gscript*: a piece of executable script that validates that a user is allowed to modify this parcel. The concept is similar to output scripts in Bitcoin. The gscript is assumed to be an ECDSA public key.
    * A *payload*: arbitrary data
    * A *witness*: a piece of data that cryptographically *proves* that this request was authorized.  
    * Time-to-Live (TTL): a timestamp before which this parcel must be kept, on a best effort basis.
  
   The simplest form of a gscript is a public verifying key (ECDSA). In that case the *witness* will be a signature for the hash of the hashes of the (gscript, payload, TTL). Extensions to include more complex forms of validations can be explored later.
  
   Parcels should have a static maximum size (say 64KB)
  
   Before accepting the parcel the database server MUST validate that the *gscript*, *witness*, and *payload* match, that is, that the signature provided is valid.
  
1. LOAD:  
   A LOAD request retrieves one or more parcels from the server.
   The data is queried by an alphanumeric range (min, max) pair, and is matched against an index of all hashes of *gscripts* for all parcels.

   All parcels matching the range of hashes should be returned within a limit (say, 20) -- ordered by the hash of the gscript.
   The whole (gscript, payload, witness) tuple must be returned.

   Upon receiving the parcels the client MUST validate gscripts and witnesses for all, marking the server as compromised if validation fails.

## Basic client-to-client communication

With these primitives a simple one-way communication can be obtained.

Before starting:
* The receiver MUST know a public verifying key that corresponds to a secret signing key the sender possesses.

* The sender MUST know an encryption key corresponding to a decryption key known to the receiver.

The communication protocol goes like:

1. The sender makes a STORE request to the server
   * The operation might be repeated multiple times, and across multiple servers for reliability.
1. The receiver polls the server with LOAD requests
   * The (min, max) range must include the hash of the sender's public key (it's possible to query for exact match, ranges will have other uses discussed further down).
   * Once a valid parcel is received that corresponds to the sender's public key, the payload is decrypted using the receiver's secret decryption key.

For a continued flow of data, all that is required is for a series of public keys be agreed -- this can be obtained using a master hierarchical deterministic (HD) key, and agreed upon sequence of derivation paths<sup>[2](#footnote02)</sup>. Alternatively, each message can contain the public signing key to be used in the next one in the chain. 

In this scenario, as long as public keys aren't reused, it isn't possible for any observer to link the different parcels as part of the same communication.

As the database server can perform analysis to link users, this protocol suggests onion routing of requests (accessing the database server through [Tor](https://www.torproject.org/)) or [parcel remailing](#parcelremailing) as described shortly.

## Bi-directional channels 

To establish a persistent bi-directional channel:

1. Alice generates an *invite* consisting of (invite signing key, encryption key).

1. Alice shares the *invite* with Bob using a side-channel.

1. Bob generates a master key to be shared with Alice in an *open channel* message.

1. Bob publishes a parcel:
   * *gscript* is the invite's public verifying key.
   * *payload* is the encrypted master public key from which the signing keys for future parcels will be derived.
   * *witness* is a signature generated using the invite's signing key.  
1. Alice polls for the *open channel* message, using the hash of the public key corresponding to the signing key in the invite. 
    Once it is received, she starts polling for the subsequent parcels using the keys derived from the master key.

1. Bob uses this Bob->Alice uni-directional channel to send Alice a new *invite* message for the corresponding Alice->Bob channel. Repeat steps 1-5 with Alice/Bob switching places.

An outside actor with no access to the private keys in Alice's and Bob's devices can only disrupt this process by obtaining the *invite* before step 5 is completed -- thus the *invite* message needs to be at least temporarily secured.

Furthemore an eavesdropper (including the database server) can only obtain further information linking both by network analysis. For many applications that level of security is acceptable -- as most popular service providers suffer from the same limitation. It's possible to mitigate that issue using futher techniques.

A database server can definitely deny service to an IP address, though this can also be mitigated by using multiple servers and onion routing.

A man-in-the-middle attack cannot achieve more than can a malicious database server.

## Public mailboxes

Using the above database primitives it's also possible to generate a "public mailbox" that can be widely shared so as to allow anonymous invites to be sent to an user.

Such a mailbox would be a tuple (encryption key, base hash, range).

For Alice to send an invite to Bob's mailbox she must:

1. Obtain (by multiple random attempts) a signing key such that its hash lies between (base hash, base hash + range).

1. Encrypt the invite using Bob's encryption key.

1. Publish a parcel where:
   * *gscript* is the public key obtained in 1.
   * *payload* is the encrypted invite followed by the hash of the cleartext invite.
   * *witness* is a signature obtained with the key found in 1.

To receive the invites Bob must:

1. Poll for parcels in the range (base hash, base hash + range).

1. For each parcel found the payload must be decrypted and the hash must match the cleartext invite.

1. Parcels whose hashes and cleartext invite don't match should be ignored.

Note that *range* is an important number, as it defines how much work (key generation, hashing) must be done to send a message to a mailbox.

A smaller number would prevent DoS more effectively, and reduce the cost of looking through parcels that randomly
match the hash range, while making it costlier for legitimate users to send messages.

To prevent older messages crowding out newer ones, hashes between (base hash, bashe hash + timestamp*range) could be used. Bob would poll for parcels from a certain timestamp in the near past to another one in the near future.

To further simplify the sharing of mailbox addresses, the base hash can be derived from the public encryption key, and the range
can be expressed as a power of two, or assumed to be a standard number.


## <a name="parcelremailing">Parcel</a> Remailers

To mitigate network analysis risks, the idea of the "public mailbox" can be harnessed to implement a *Parcel Remailer*.

For Alice to send a parcel to Bob, through Carol's remailer, she must:

1. Encrypt the parcel using Carol's mailbox's encryption key.

1. Send the encrypted parcel to Carol's mailbox.

Carol's Remailer would then:

1. Publicly anounce her "open mailbox" as willing to receive remailing requests.

1. When a message arrives at the mailbox, decrypt it and publish the decrypted parcel to the server.

Multiple remailers can be chained in onion-routing manner, further thwarting network analysis -- as long as any one remailer in the chain is "honest".

Furthermore, it is very easy for any user to become a remailer, regardless of computing/network resources, by setting a mailbox
with low enough range. Known remailers can be gossiped around between users.

Users wishing to send a remailed parcel should keep a list of multiple remailers, which will lower the amount of work necessary to find a good public key for one of them.

## Public broadcast messages

The same primitives can be used for broadcasting a public "timeline" of messages, by publicly sharing a master public key, and then delivering multiple ordered parcels using the derived public keys.

It must be noted that it is trivial for an individual database server to "ban" a public "broadcaster" by dropping all parcels that correspond to any of their keys.

Here is a tentative scheme for making censorship of broadcast flows costly -- with the downside of making "following" broadcasters costly too:

- Instead of just a master signing key, the broadcaster announces a range of hashes to look for his messages -- much in the same way as a
public inbox, except it's a public outbox -- the broadcaster's signature for each payload will need to be inserted in the parcel payload itself. 
- Anyone following that broadcaster must download *all* the parcels within the range andfigure out which ones correspond to the desired broadcaster.
- To give "temporary plausible deniability" and make preemptive censorship hard, the payload can be uploaded not in cleartext, but encrypted using an encryption key derived from Nth hash of the parcel's gscript.
- *N* must be large enough to delay figuring out which parcels correspond to which broadcaster before followers download the encrypted content.
- To preemptively censor the broadcaster, a database server would need to delay considerably a range of hashes, interfering with
activity by all users -- which would be at very least detectable, and most likely costly in terms of competitiveness vs other providers.

It must also be noted that sharing of messages signed by third parties through a friend-to-friend network of graffiti protocol channels would 
be hard to censor too.


## Funding Servers

The database servers function much in the same way as general TCP/IP infrastructure, transmitting parcels of data back and forth, and
if the protocol becomes popular paying for that service might become an issue.

It's likely that these services may be provided by ISPs or other paid providers.

For enhanced privacy, servers could allow for LN payments that generate "tokens" that can be used until a certain amount of traffic is reached. By using Tor, multiple tokens and remailers -- it might be possible to prevent linking payment identities to parcels and thus avoid a new vector for network analysis.

Alternatively a large enough number of non-profit providers might split the domain of gscript hashes so that each only needs to deal with
a small part of the traffic -- with some level of redundancy.

Exactly who provides the server functionality is mostly irrelevant to the protocol, and new research can be done in collaborative protocols
for decentralizing this function (perhaps adpating existing ones) -- if needed.

## Applications

Besides messaging between users, this protocol could be used as a base layer of communication between multiple applications.

It's also possible that the *gscript* validation mechanism could be repurposed to enforce a subset of business logic (perhaps partially revealing user data), in a way similar to "smart contracts". It's unclear whether that could be useful or not.


## References

TODO

Modify document to use Key Words as per https://tools.ietf.org/html/rfc2119



<a name="footnote01">1</a>: LinkedIn lose 117 million details https://www.teiss.co.uk/linkedin-hacker-jailed/

<a name="footnote02">2</a>: See Bitcoin's xpub https://support.blockchain.com/hc/en-us/articles/360000939843-Understanding-the-xPub-and-address-generation
